Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16]; 
    uniform vec3 reflectance[16];
    uniform float refractiveIndicies[16];

    uniform samplerCube background;

    in vec4 rayDir;

    out vec4 fragmentColor;

    vec3 objectColor = vec3(0, 1, 0);
    vec3 lightPoint = vec3(2, 2, 0);
    float lightPower = 200.0;
    float epsilon = 0.001;
    int n_Refl = 2;

    vec3 surfaceNormal(vec4 v, mat4 quadric) {
        float a = quadric[0][0];
        float b = quadric[0][1];
        float c = quadric[0][2];
        float d = quadric[0][3];
        float e = quadric[1][0];
        float f = quadric[1][1];
        float g = quadric[1][2];
        float h = quadric[1][3];
        float i = quadric[2][0];
        float j = quadric[2][1];
        float k = quadric[2][2];
        float l = quadric[2][3];
        float m = quadric[3][0];
        float n = quadric[3][1];
        float o = quadric[3][2];
        float p = quadric[3][3];

        v[3] = 1.0;
        float fx = dot(vec4(a, e, i, m), v) + dot(vec4(a, b, c, d), v);
        float fy = dot(vec4(b, f, j, n), v) + dot(vec4(e, f, g, h), v);
        float fz = dot(vec4(c, g, k, o), v) + dot(vec4(i, j, k, l), v);
        return normalize(vec3(fx, fy, fz));
    }

    vec4 surfaceNormalSide(vec4 p, mat4 quadric, vec4 d){
        vec3 N = surfaceNormal(p, quadric);
        vec4 N4 = vec4(N, 0.0);
        if (dot(d.xyz, N4.xyz) > 0.0){
            return -1.0 * N4;
        } else {
            return N4; 
        }
    }

    vec3 shade(
        vec3 kd,
        vec3 normal,
        vec3 viewDir,
        vec3 lightDir,
        vec3 lightPowerDensity) {
        float cosTheta = dot(normal, lightDir);
        if(cosTheta < 0.0) {
            return vec3(0.0,0.0,0.0);
        } else {
            return kd * lightPowerDensity * cosTheta;
        }
    }

    // vec3 shade( vec4 ksg,
    //     vec3 normal, vec3 viewDir,
    //     vec3 lightDir, vec3 lightPowerDensity){
    //     float cosTheta = dot(normal, lightDir);
    //     if(cosTheta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     }
    //     vec3 halfway = normalize(viewDir + lightDir);
    //     float cosDelta = dot(normal,  halfway);
    //     if(cosDelta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     } else{
    //         return lightPowerDensity * ksg.xyz * pow(cosDelta, ksg.w);
    //     }
    // }



  
    float intersectClippedQuadric(mat4 A, vec4 e, vec4 d, mat4 B){
        float a = dot(d * A, d);
        float b = dot(d * A, e) + dot(e * A, d);
        float c = dot(e * A, e);
        float D = sqrt(b*b-4.0*a*c);
        float t1 = (-b + D) / (2.0*a);
        float t2 = (-b - D) / (2.0*a);
        vec4 h1 = e + (t1*d);
        vec4 h2 = e + (t2*d);
        if (dot(h1*B, h1) > 0.0){
            t1 = -1.0;
        }
        if (dot(h2*B, h2) > 0.0){
            t2 = -1.0;
        }
        return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
    }

    float findBestHit(vec4 e, vec4 d, out int bestQuadricIndex)
    {
        float bestT = -1.0;
        for(int i = 0; i < 16; i++){
            float t = intersectClippedQuadric(quadrics[i], e, d, clippers[i]);
            if(t > 0.0 && (bestT < 0.0 || t < bestT)){
                bestT = t;
                bestQuadricIndex = i;
            }
        }
        return bestT;
    }

    vec3 DReflect(vec3 inDir, vec3 normal) {
        return inDir - normal * dot(normal, inDir) * 2.0;
    }

    vec3 DRefract(vec3 inDir, vec3 normal, float refractiveIndex) {
        float ri = refractiveIndex;
        float cosa = - dot(normal, inDir);
        if (cosa < 0.0) { cosa = -cosa; normal = -normal; ri = 1.0/ri; }      
        float disc = 1.0 - (1.0 - cosa * cosa) / ri / ri;       
        if (disc < 0.0) return reflect(inDir, normal);
        return inDir * (1.0/ri) + normal * (cosa / ri - sqrt(disc)) ;
    }

    vec3 IReflect(vec3 inDir, vec3 normal, vec3 minReflectance) {
        float cosa = abs(dot(normal, inDir));
        return minReflectance + (1.0-minReflectance)*pow( 1.0-cosa, 5.0 ); 
    }

    vec3 IRefract(vec3 inDir, vec3 normal, vec3 minReflectance) {
        return vec3(1.0, 1.0, 1.0) - IReflect(inDir, normal, minReflectance); 
    }

    struct RRPoint
    {
        int i;
        vec4 p;
        vec4 d;
    };

    struct RRPointStack
    {
        int i;
        RRPoint data[16];
    };

    struct ColorStack
    {
        int i;
        vec4 data[16];
    };

    void RRPointStackPop(RRPointStack s){
        s.i--;
    }

    void RRPointStackPush(out RRPointStack S, out ColorStack L, out ColorStack R, RRPoint e){
        S.data[S.i++] = e;
        L.data[L.i++] = vec4(-1);
        R.data[R.i++] = vec4(-1);
    }

    ColorStack ColorStackCreate(){
        ColorStack colorStack;
        for (int i = 0; i < 16; ++i)
        {
            colorStack.data[i] = vec4(-1);
        }
        return colorStack;
    }

    void ColorStackPop(ColorStack s){
        s.i--;
    }
    void PopStack(out RRPointStack S, out ColorStack L, out ColorStack R){
        S.i--;
        L.i--;
        R.i--;
    }

    float diffuseShading(vec4 p, vec4 N){
        vec4 lightDir = vec4(lightPoint, 0.0) - p;
        float lightDist = dot(lightDir, lightDir);
        vec4 lightDirNorm = vec4(normalize(lightDir.xyz), 0.0);
        int lightQuadraticIndex;
        float lightT = findBestHit(p + epsilon*N, lightDirNorm, lightQuadraticIndex);
        float intensity = 0.0;
        if (lightT < 0.0 || lightDist < (lightT * lightT)) {
            intensity = dot(N, lightDirNorm) * lightPower / (4.0*3.14*lightDist);
        }
        return intensity;
    }

    bool goLeft(RRPoint root, out RRPoint rrpoint, out vec4 color){
        vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);

        vec3 minReflectance = reflectance[root.i];
        // if (dot(minReflectance, minReflectance) == 0.0) {
        //     color = vec4(objectColor * diffuseShading(root.p, N),1);
        //     return false;
        // }

        vec4 reflectD = vec4(DReflect(root.d.xyz, N.xyz), 0.0);
        vec4 e = root.p + epsilon*reflectD;
        int quadricIndex;
        float t = findBestHit(e, reflectD, quadricIndex);
        bool isColor = (t <= 0.0);
        if (isColor) {
            color = vec4(texture(background, reflectD.xyz).rgb, 1);
            return false;
        }

        rrpoint.i = quadricIndex;
        rrpoint.p = e + t*reflectD;
        rrpoint.d = reflectD;
        return true;
    }

    bool goRight(RRPoint root, out RRPoint rrpoint, out vec4 color){
        vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);

        float refractiveIndex= refractiveIndicies[root.i];
        // if (refractiveIndex < 0.0) {
        //     color = vec4(objectColor * diffuseShading(root.p, N),1);
        //     return false;
        // }

        vec4 refractD = vec4(DRefract(root.d.xyz, N.xyz, refractiveIndex), 0.0);
        vec4 e = root.p + epsilon*refractD;
        int quadricIndex;
        float t = findBestHit(e, refractD, quadricIndex);
        bool isColor = (t <= 0.0);
        if (isColor) {
            color = vec4(texture(background, refractD.xyz).rgb, 1);
            return false;
        }

        rrpoint.i = quadricIndex;
        rrpoint.p = e + t*refractD;
        rrpoint.d = refractD;
        return true;
    }
    struct step3and4Out
    {
        RRPointStack S;
        ColorStack L;
        ColorStack R;
        RRPoint current;
    };

    step3and4Out step3and4(RRPointStack S, ColorStack L, ColorStack R, RRPoint current){
        for (int i = 0; i < n_Refl; ++i)
        {
            // RRPointStackPush(S, L, R, current);
            if (dot(reflectance[current.i], reflectance[current.i]) > 0.0) {
                RRPoint left;
                vec4 leftColor;
                bool useRRPoint = goLeft(current, left, leftColor);
                if (useRRPoint){
                    current = left;
                } else {
                    L.data[S.i-1] = leftColor;
                    break;
                }
            } else {
                vec4 N = surfaceNormalSide(current.p, quadrics[current.i], current.d);
                L.data[S.i-1] = vec4(objectColor * diffuseShading(current.p, N),1);
                break;
            }
        }
        step3and4Out r;
        r.S = S;
        r.L = L;
        r.R = R;
        r.current = current;
        return r;
    }

    vec4 relfectRefract(vec4 e, vec4 d){
        int quadricIndex;
        float t = findBestHit(e, d, quadricIndex);
        if (t < 0.0){
            return vec4(texture(background, d.xyz).rgb, 1);
        }
        RRPoint root;
        root.i = quadricIndex;
        root.p = e + t*d;
        root.d = d;

        RRPointStack S;
        ColorStack L = ColorStackCreate();
        ColorStack R = ColorStackCreate();
        RRPoint current = root;
        
        for (int i = 0; i < n_Refl; ++i) {
            RRPointStack S_t = S;
            ColorStack L_t = L;
            ColorStack R_t = R;
            RRPoint current_t = current;
            step3and4Out r = step3and4(S_t, L_t, R_t, current_t);
            S = r.S;
            L = r.L;
            R = r.R;
            current = r.current;

        //     if(S.i == 0) break;

        //     current = S.data[S.i-1];
        //     if (refractiveIndicies[current.i] > 0.0) {
        //         RRPoint right;
        //         vec4 rightColor;
        //         bool useRRPoint = goRight(root, right, rightColor);
        //         if (useRRPoint){
        //             current = right;
        //         } else {

        //             R.data[S.i-1] = rightColor;
        //             for (int i = 0; i < n_Refl; ++i)
        //             {
        //                 vec4 N = surfaceNormalSide(current.p, quadrics[current.i], current.d);
        //                 vec4 intensity = vec4(IReflect(current.d.xyz, N.xyz, reflectance[current.i].xyz), 1);
        //                 vec4 rr = (intensity * L.data[S.i-1]) + ((vec4(1, 1, 1, 0) - intensity) * R.data[S.i-1]);
        //                 if (S.i == 0){
        //                     return rr;
        //                 }
        //                 PopStack(S, L, R);
        //                 if (L.data[S.i-1][0] < 0.0)
        //                 {
        //                     L.data[S.i-1] = rr;
        //                 } else {
        //                     R.data[S.i-1] = rr;
        //                     break;
        //                 }
        //             }
        //             current = S.data[S.i-1];
        //             if (refractiveIndicies[current.i] > 0.0) {
        //                 RRPoint right;
        //                 vec4 rightColor;
        //                 bool useRRPoint = goRight(current, right, rightColor);
        //                 if (useRRPoint){
        //                     current = right;
        //                     // GOTO STEP 3
        //                 } else {
        //                     L.data[S.i-1] = rightColor;
        //                     // GOTO STEP 5
        //                 }
        //             }
        //         }
        //     }
        }

        return vec4(0);



        // ######

        // int quadricIndex;
        // float t = findBestHit(e, d, quadricIndex);
        // if (t < 0.0){
        //     return vec4(texture(background, d.xyz).rgb, 1);
        // }
        // RRPoint root;
        // root.i = quadricIndex;
        // root.p = e + t*d;
        // root.d = d;

        // vec3 intensity = vec3(1,1,1);
        // for (int i = 0; i < 10; ++i)
        // {
        //     vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);
        //     if (dot(reflectance[root.i], reflectance[root.i]) > 0.0) {
        //         RRPoint left;
        //         vec4 leftColor;
        //         bool useRRPoint = goLeft(root, left, leftColor);
        //         if (useRRPoint){
        //             root = left;
        //         } else {
        //             return leftColor;
        //         }
        //     } else if (refractiveIndicies[root.i] > 0.0) {
        //         RRPoint right;
        //         vec4 rightColor;
        //         bool useRRPoint = goRight(root, right, rightColor);
        //         if (useRRPoint){
        //             root = right;
        //         } else {
        //             return rightColor;
        //         }
        //     } else {
        //         return vec4(objectColor * diffuseShading(root.p, N),1);
        //     }
        // }
        // return vec4(intensity, 1);
    }

  void main() {
    vec4 lightPoint4 = vec4(lightPoint, 0.0);
    vec4 d = vec4(normalize(rayDir.xyz), 0.0);
    vec4 e = eyePosition;
    fragmentColor = relfectRefract(e, d);
  }
`;