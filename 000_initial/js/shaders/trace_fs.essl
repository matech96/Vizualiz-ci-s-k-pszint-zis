Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16];


    in vec4 rayDir;

    out vec4 fragmentColor;

    vec4 objectColor = vec4(0, 1, 0, 1);
    vec4 lightDir = vec4(0, 0, 1, 0);
    //Sphere tracing leallasi kriteriuma 
    float epsilon = 0.001;

    //Kvaternio szorzas
    vec4 quatMult( vec4 q1, vec4 q2 ) {
        vec4 r;

        r.x   = q1.x * q2.x - dot( q1.yzw, q2.yzw );
        r.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross( q1.yzw, q2.yzw );

        return r;
    }

    //Kvaternio negyzet
    vec4 quatSq( vec4 q ) {
        vec4 r;

        r.x   = q.x * q.x - dot( q.yzw, q.yzw );
        r.yzw = 2.0 * q.x * q.yzw;

        return r;
    }

    //Valami
    void iterateIntersect( inout vec4 q, inout vec4 qp) {
        for( int i = 0; i < 10; i++ ) {
            qp = 2.0 * quatMult(q, qp);
            q = quatSq(q) + vec4(1, 0.5, -0.1, 0.3);

            if( dot( q, q ) > 7.0 ) {
                break;
            }
        }
    }

    float distJulia(vec3 p) {
        vec4 z = vec4( p, 0.0 );
        vec4 zp = vec4( 1, 0.0, 0.0, 0.0 );
        iterateIntersect( z, zp );
        float normZ = length( z );
        return 0.5 * normZ * log( normZ ) / length( zp );
    }

    float dist(vec3 p) {
        return distJulia(p);
        //return distSph(p);
    }

    //Gradiens becslese egy pontban numerikus derivalassal
    vec3 estimateGradient(vec3 p) {
        return normalize(vec3(
        dist(p + vec3(epsilon, 0, 0)) - dist(p - vec3(epsilon, 0, 0)),
        dist(p + vec3(0, epsilon, 0)) - dist(p - vec3(0, epsilon, 0)),
        dist(p + vec3(0, 0, epsilon)) - dist(p - vec3(0, 0, epsilon))));
    }
  
  float intersectClippedQuadric(mat4 A, vec4 e, vec4 d, mat4 B){
	float a = dot(d * A, d);
	float b = dot(d * A, e) + dot(e * A, d);
	float c = dot(e * A, e);
	float D = sqrt(b*b-4.0*a*c);
	float t1 = (-b + D) / (2.0*a);
	float t2 = (-b - D) / (2.0*a);
    vec4 h1 = e + (t1*d);
    vec4 h2 = e + (t2*d);
    if (dot(h1*B, h1) > 0.0){
        t1 = -1.0;
    }
    if (dot(h2*B, h2) > 0.0){
        t2 = -1.0;
    }
	return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
  }

  float findBestHit(vec4 e, vec4 d, out int bestQuadricIndex){
    float bestT = -1.0;
    for(int i = 0; i < 16; i++){
        float t = intersectClippedQuadric(quadrics[i], e, d, clippers[i]);
        if(t > 0.0 && (bestT < 0.0 || t < bestT)){
            bestT = t;
            bestQuadricIndex = i;
        }
    }
    return bestT;
  }

  void main() { 
    vec4 d = vec4(normalize(rayDir.xyz), 0.0);
    vec4 e = eyePosition;
    int quadricIndex;
	float t = findBestHit(e, d, quadricIndex);
	fragmentColor = vec4(1, 1, 1, 1);
	if (t > 0.0) {
		fragmentColor = objectColor;
	}
  }
`;