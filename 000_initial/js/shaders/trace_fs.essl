Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16];


    in vec4 rayDir;

    out vec4 fragmentColor;

    vec3 objectColor = vec3(0, 1, 0);
    vec3 lightDir = vec3(1, 0, 0);
    //Sphere tracing leallasi kriteriuma 
    float epsilon = 0.001;

    //Kvaternio szorzas
    vec4 quatMult( vec4 q1, vec4 q2 ) {
        vec4 r;

        r.x   = q1.x * q2.x - dot( q1.yzw, q2.yzw );
        r.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross( q1.yzw, q2.yzw );

        return r;
    }

    //Kvaternio negyzet
    vec4 quatSq( vec4 q ) {
        vec4 r;

        r.x   = q.x * q.x - dot( q.yzw, q.yzw );
        r.yzw = 2.0 * q.x * q.yzw;

        return r;
    }

    //Valami
    void iterateIntersect( inout vec4 q, inout vec4 qp) {
        for( int i = 0; i < 10; i++ ) {
            qp = 2.0 * quatMult(q, qp);
            q = quatSq(q) + vec4(1, 0.5, -0.1, 0.3);

            if( dot( q, q ) > 7.0 ) {
                break;
            }
        }
    }


    vec3 surfaceNormal(vec4 p, mat4 quadrics) {
        float a = quadrics[0][0];
        quadrics[0][0] = 0.0;
        vec4 px = vec4(1, 0, 0, 0);
        float fx = (px * quadrics + quadrics * px)[0] + 2.0*a*p[0];
        quadrics[0][0] = a;

        float f = quadrics[1][1];
        quadrics[1][1] = 0.0;
        vec4 py = vec4(0, 1, 0, 0);
        float fy = (py * quadrics + quadrics * py)[0] + 2.0*f*p[1];
        quadrics[1][1] = f;

        float k = quadrics[2][2];
        quadrics[2][2] = 0.0;
        vec4 pz = vec4(0, 0, 1, 0);
        float fz = (pz * quadrics + quadrics * pz)[0] + 2.0*k*p[2];
        quadrics[2][2] = k;
        return normalize(vec3(fx, fy, fz));
    }

    vec3 surfaceNormalSide(vec4 p, mat4 quadrics, vec4 d){
        vec3 N = surfaceNormal(p, quadrics);
        vec4 N4 = vec4(N, 0.0);
        if (dot(d, N4) > 0.0){
            return -1.0 * N;
        } else {
            return N;
        }
    }
  
  float intersectClippedQuadric(mat4 A, vec4 e, vec4 d, mat4 B){
	float a = dot(d * A, d);
	float b = dot(d * A, e) + dot(e * A, d);
	float c = dot(e * A, e);
	float D = sqrt(b*b-4.0*a*c);
	float t1 = (-b + D) / (2.0*a);
	float t2 = (-b - D) / (2.0*a);
    vec4 h1 = e + (t1*d);
    vec4 h2 = e + (t2*d);
    if (dot(h1*B, h1) > 0.0){
        t1 = -1.0;
    }
    if (dot(h2*B, h2) > 0.0){
        t2 = -1.0;
    }
	return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
  }

  float findBestHit(vec4 e, vec4 d, out int bestQuadricIndex){
    float bestT = -1.0;
    for(int i = 0; i < 16; i++){
        float t = intersectClippedQuadric(quadrics[i], e, d, clippers[i]);
        if(t > 0.0 && (bestT < 0.0 || t < bestT)){
            bestT = t;
            bestQuadricIndex = i;
        }
    }
    return bestT;
  }

  void main() { 
    vec4 lightDir4 = vec4(lightDir, 0.0);
    vec4 d = vec4(normalize(rayDir.xyz), 0.0);
    vec4 e = eyePosition;
    int quadricIndex;
	float t = findBestHit(e, d, quadricIndex);
	fragmentColor = vec4(1, 1, 1, 1);
	if (t > 0.0) {
        vec4 p = e + t*d;
        vec3 N = surfaceNormalSide(p, quadrics[quadricIndex], d);
        int tmp;
        float lightT = findBestHit(p + 1.0*vec4(N, 0.0), -1.0 * lightDir4, tmp);
        float intensity = 0.0;
        if (lightT < 0.0) {
            intensity = dot(N, lightDir);
        }
        fragmentColor = vec4(objectColor * intensity, 1);
	}
  }
`;