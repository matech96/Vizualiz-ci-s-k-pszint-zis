Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16];

    vec4 lightPosition = vec4(0,0,10,1);
    
    uniform samplerCube background;
    


    in vec4 rayDir;

    out vec4 fragmentColor;

    //Sphere tracing leallasi kriteriuma 
    float epsilon = 0.0001;
    
    //Tavolsagfuggveny 1 sugaru gombhoz.
    float distSph(vec3 p) {
        return length(p)-1.0;
    }
  
    //Kvaternio szorzas
    vec4 quatMult( vec4 q1, vec4 q2 ) {
        vec4 r;

        r.x   = q1.x * q2.x - dot( q1.yzw, q2.yzw );
        r.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross( q1.yzw, q2.yzw );

        return r;
    }

    //Kvaternio negyzet
    vec4 quatSq( vec4 q ) {
        vec4 r;

        r.x   = q.x * q.x - dot( q.yzw, q.yzw );
        r.yzw = 2.0 * q.x * q.yzw;

        return r;
    }

    //Valami
    void iterateIntersect( inout vec4 q, inout vec4 qp) {
        for( int i = 0; i < 20; i++ ) {
            qp = 2.0 * quatMult(q, qp);
            q = quatSq(q) + vec4(0, 0.5, -0.5, 0.3);

            if( dot( q, q ) > 7.0 ) {
                break;
            }
        }
    }

    //A Julia tavolsagfuggvenye
    float distJulia(vec3 p) {
        vec4 z = vec4( p, 0.0 );
        vec4 zp = vec4( 1, 0.0, 0.0, 0.0 );
        iterateIntersect( z, zp );
        float normZ = length( z );
        return 0.5 * normZ * log( normZ ) / length( zp );
    }



    //Altalanos tavolsagfuggveny, hogy ne a lenti kodot kelljen atirni
    float dist(vec3 p) {
        return distJulia(p);
        //return distSph(p);
    }

    //Gradiens becslese egy pontban numerikus derivalassal
    vec3 estimateGradient(vec3 p) {
        return normalize(vec3(
        dist(p + vec3(epsilon, 0, 0)) - dist(p - vec3(epsilon, 0, 0)),
        dist(p + vec3(0, epsilon, 0)) - dist(p - vec3(0, epsilon, 0)),
        dist(p + vec3(0, 0, epsilon)) - dist(p - vec3(0, 0, epsilon))));
    }
    
    
    //Mukodo:
    float intersectQuadric(vec4 e, vec4 d, mat4 A, mat4 B) {
        vec4 dA = d*A;
        float a = dot(dA,d);
        float b = dot(dA,e) + dot(e,A*d);
        float c = dot(e*A,e);
        float D = b*b-4.0*a*c;
        if (D < 0.0)
            return -1.0;
        D = sqrt(D);
        a = 0.5/a;
        float t1 = (D-b)*a;
        float t2 = -(b+D)*a;
        return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
    }
    
    
    //Mukodo:
    float intersectQuadricClipped(vec4 e, vec4 d, mat4 A, mat4 B) {
        vec4 dA = d*A;
        float a = dot(dA,d);
        float b = dot(dA,e) + dot(e,A*d);
        float c = dot(e*A,e);
        float D = b*b-4.0*a*c;
        if (D < 0.0)
            return -1.0;
        D = sqrt(D);
        a = 0.5/a;
        float t1 = (D-b)*a;
        float t2 = -(b+D)*a;
        
        vec4 r1, r2;
        if (t1<0.0) {
            r2 = e+d*t2;
            if (t2<0.0 || dot(r2*B,r2)>0.0)
                return -1.0;
            else
                return t2;
        }
        else {
            if (t2<0.0) {
                r1 = e+d*t1;
                if (t1<0.0 || dot(r1*B,r1)>0.0)
                    return -1.0;
                else
                    return t1;
            }
            else {
                r1 = e+d*t1;
                r2 = e+d*t2;
                a = dot(r1*B,r1);
                b = dot(r2*B,r2);
                
                if (a<=0.0)
                    if (b<=0.0)
                        return min(t1,t2);
                    else
                        return t1;
                else
                    if (b<=0.0)
                        return t2;
                    else
                        return -1.0;
            }
        }
        
        //return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
    }
    
    bool findBestHit(vec4 e, vec4 d, out float bestT, out int bestQuadricIndex) {
        bestT = 99999999.0;
        bestQuadricIndex = -1;
        for (int i = 0; i < 16; i++) {
            float t = intersectQuadricClipped(e, d, quadrics[i], clippers[i]);
            if (t>=0.0 && t<bestT) {
                bestT = t;
                bestQuadricIndex = i;
            }
        }
        return bestQuadricIndex != -1;
    }

    float rand(vec3 co)
    {
        return fract(sin( dot(co.xyz ,vec3(12.9898,78.233,45.5432) )) * 43758.5453);
    }

    //Fragment shader kod.
    void main(void) {
        //Sugar haladasi iranya
        vec4 dir = vec4(normalize(rayDir.xyz), 0.0);
        //Sugar kiindulasa
        vec4 e = eyePosition;
        
        float t;
        int i;
        bool hasHit = findBestHit(e, dir, t, i);
        fragmentColor = vec4(texture(background, dir.xyz).rgb, 1);
        while (hasHit) {
            e += dir*t;
            vec3 normal = normalize( (e * quadrics[i] + quadrics[i] * e).xyz );
            e.xyz += normal*epsilon*dot(normal,dir.xyz);
            dir.xyz = reflect(rayDir, vec4(normal, 0.0)).xyz;
            fragmentColor.rgb *= vec3(0.95,0.9,0.85);
            if (brdfs[i][0] < 0.0)
            {
                fragmentColor.rgb = vec3(0,1,0);
            }
            if (length(fragmentColor.rgb)<0.1)
            {
                break;
            }
            else
            {
                hasHit = findBestHit(e, dir, t, i);
            }
        }
    }
`;