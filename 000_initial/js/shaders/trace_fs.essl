Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16]; 
    uniform float reflectance[16];

    uniform samplerCube background;

    in vec4 rayDir;

    out vec4 fragmentColor;

    vec3 objectColor = vec3(0, 1, 0);
    vec3 lightPoint = vec3(2, 2, 0);
    float lightPower = 200.0;
    float epsilon = 0.001;

    vec3 DReflect(vec3 inDir, vec3 normal) {
        return inDir - normal * dot(normal, inDir) * 2.0;
    }

    vec3 DRefract(vec3 inDir, vec3 normal, float refractiveIndex) {
        float ri = refractiveIndex;
        float cosa = - dot(normal, inDir);
        if (cosa < 0.0) { cosa = -cosa; normal = -normal; ri = 1.0/ri; }      
        float disc = 1.0 - (1.0 - cosa * cosa) / ri / ri;       
        if (disc < 0.0) return reflect(inDir, normal);
        return inDir * (1.0/ri) + normal * (cosa / ri - sqrt(disc)) ;
    }

    vec3 IReflect(vec3 inDir, vec3 normal, vec3 minReflectance) {
        float cosa = abs(dot(normal, inDir));
        return minReflectance + (1.0-minReflectance)*pow( 1.0-cosa, 5.0 ); 
    }

    vec3 IRefract(vec3 inDir, vec3 normal, vec3 minReflectance) {
        return vec3(1.0, 1.0, 1.0) - IReflect(inDir, normal, minReflectance); 
    }

    vec3 surfaceNormal(vec4 v, mat4 quadric) {
        float a = quadric[0][0];
        float b = quadric[0][1];
        float c = quadric[0][2];
        float d = quadric[0][3];
        float e = quadric[1][0];
        float f = quadric[1][1];
        float g = quadric[1][2];
        float h = quadric[1][3];
        float i = quadric[2][0];
        float j = quadric[2][1];
        float k = quadric[2][2];
        float l = quadric[2][3];
        float m = quadric[3][0];
        float n = quadric[3][1];
        float o = quadric[3][2];
        float p = quadric[3][3];

        v[3] = 1.0;
        float fx = dot(vec4(a, e, i, m), v) + dot(vec4(a, b, c, d), v);
        float fy = dot(vec4(b, f, j, n), v) + dot(vec4(e, f, g, h), v);
        float fz = dot(vec4(c, g, k, o), v) + dot(vec4(i, j, k, l), v);
        return normalize(vec3(fx, fy, fz));
    }

    vec4 surfaceNormalSide(vec4 p, mat4 quadric, vec4 d){
        vec3 N = surfaceNormal(p, quadric);
        vec4 N4 = vec4(N, 0.0);
        if (dot(d.xyz, N4.xyz) > 0.0){
            return -1.0 * N4;
        } else {
            return N4; 
        }
    }

    vec3 shade(
        vec3 kd,
        vec3 normal,
        vec3 viewDir,
        vec3 lightDir,
        vec3 lightPowerDensity) {
        float cosTheta = dot(normal, lightDir);
        if(cosTheta < 0.0) {
            return vec3(0.0,0.0,0.0);
        } else {
            return kd * lightPowerDensity * cosTheta;
        }
    }

    // vec3 shade( vec4 ksg,
    //     vec3 normal, vec3 viewDir,
    //     vec3 lightDir, vec3 lightPowerDensity){
    //     float cosTheta = dot(normal, lightDir);
    //     if(cosTheta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     }
    //     vec3 halfway = normalize(viewDir + lightDir);
    //     float cosDelta = dot(normal,  halfway);
    //     if(cosDelta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     } else{
    //         return lightPowerDensity * ksg.xyz * pow(cosDelta, ksg.w);
    //     }
    // }



  
  float intersectClippedQuadric(mat4 A, vec4 e, vec4 d, mat4 B){
	float a = dot(d * A, d);
	float b = dot(d * A, e) + dot(e * A, d);
	float c = dot(e * A, e);
	float D = sqrt(b*b-4.0*a*c);
	float t1 = (-b + D) / (2.0*a);
	float t2 = (-b - D) / (2.0*a);
    vec4 h1 = e + (t1*d);
    vec4 h2 = e + (t2*d);
    if (dot(h1*B, h1) > 0.0){
        t1 = -1.0;
    }
    if (dot(h2*B, h2) > 0.0){
        t2 = -1.0;
    }
	return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
  }

  float findBestHit(vec4 e, vec4 d, out int bestQuadricIndex){
    float bestT = -1.0;
    for(int i = 0; i < 16; i++){
        float t = intersectClippedQuadric(quadrics[i], e, d, clippers[i]);
        if(t > 0.0 && (bestT < 0.0 || t < bestT)){
            bestT = t;
            bestQuadricIndex = i;
        }
    }
    return bestT;
  }

  vec4 relfectRefract(vec4 e, vec4 d){
    int quadricIndex;
    float t = findBestHit(e, d, quadricIndex);
    if (t > 0.0) {
        vec4 p = e + t*d;
        vec4 N = surfaceNormalSide(p, quadrics[quadricIndex], d);
        float minReflectence = brdfs[quadricIndex][0];
        if (minReflectence > 0.0) {
            vec4 reflectD = vec4(DReflect(d.xyz, N.xyz), 0.0);
            //vec4 color = relfectRefract(p, reflectD);
        }
    } else {
        return vec4(texture(background, d.xyz).rgb, 1);
    }
  }

  void main() { 
    vec4 lightPoint4 = vec4(lightPoint, 0.0);
    vec4 d = vec4(normalize(rayDir.xyz), 0.0);
    vec4 e = eyePosition;
    int quadricIndex;
	float t = findBestHit(e, d, quadricIndex);
    fragmentColor = vec4(texture(background, d.xyz).rgb, 1);
	if (t > 0.0) {
        vec4 p = e + t*d;
        vec4 N = surfaceNormalSide(p, quadrics[quadricIndex], d);
        vec4 lightDir = lightPoint4 - p;
        float lightDist = dot(lightDir, lightDir);
        vec4 lightDirNorm = vec4(normalize(lightDir.xyz), 0.0);
        int lightQuadraticIndex;
        float lightT = findBestHit(p + epsilon*N, lightDirNorm, lightQuadraticIndex);
        float intensity = 0.0;
        if (lightT < 0.0 || lightDist < (lightT * lightT)) {
            intensity = dot(N, lightDirNorm) * lightPower / (4.0*3.14*lightDist);
        }
        fragmentColor = vec4(objectColor * intensity, 1);
	}
  }
`;