Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;

    uniform vec4 eyePosition;
    uniform mat4 quadrics[16];
    uniform mat4 clippers[16];
    uniform vec4 brdfs[16]; 
    uniform vec3 reflectance[16];
    uniform float refractiveIndicies[16];

    uniform samplerCube background;

    in vec4 rayDir;

    out vec4 fragmentColor;

    vec3 objectColor = vec3(0, 1, 0);
    vec3 lightPoint = vec3(2, 2, 0);
    float lightPower = 200.0;
    float epsilon = 0.001;

    vec3 surfaceNormal(vec4 v, mat4 quadric) {
        float a = quadric[0][0];
        float b = quadric[0][1];
        float c = quadric[0][2];
        float d = quadric[0][3];
        float e = quadric[1][0];
        float f = quadric[1][1];
        float g = quadric[1][2];
        float h = quadric[1][3];
        float i = quadric[2][0];
        float j = quadric[2][1];
        float k = quadric[2][2];
        float l = quadric[2][3];
        float m = quadric[3][0];
        float n = quadric[3][1];
        float o = quadric[3][2];
        float p = quadric[3][3];

        v[3] = 1.0;
        float fx = dot(vec4(a, e, i, m), v) + dot(vec4(a, b, c, d), v);
        float fy = dot(vec4(b, f, j, n), v) + dot(vec4(e, f, g, h), v);
        float fz = dot(vec4(c, g, k, o), v) + dot(vec4(i, j, k, l), v);
        return normalize(vec3(fx, fy, fz));
    }

    vec4 surfaceNormalSide(vec4 p, mat4 quadric, vec4 d){
        vec3 N = surfaceNormal(p, quadric);
        vec4 N4 = vec4(N, 0.0);
        if (dot(d.xyz, N4.xyz) > 0.0){
            return -1.0 * N4;
        } else {
            return N4; 
        }
    }

    vec3 shade(
        vec3 kd,
        vec3 normal,
        vec3 viewDir,
        vec3 lightDir,
        vec3 lightPowerDensity) {
        float cosTheta = dot(normal, lightDir);
        if(cosTheta < 0.0) {
            return vec3(0.0,0.0,0.0);
        } else {
            return kd * lightPowerDensity * cosTheta;
        }
    }

    // vec3 shade( vec4 ksg,
    //     vec3 normal, vec3 viewDir,
    //     vec3 lightDir, vec3 lightPowerDensity){
    //     float cosTheta = dot(normal, lightDir);
    //     if(cosTheta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     }
    //     vec3 halfway = normalize(viewDir + lightDir);
    //     float cosDelta = dot(normal,  halfway);
    //     if(cosDelta < 0) {
    //         return vec3(0.0,0.0,0.0);
    //     } else{
    //         return lightPowerDensity * ksg.xyz * pow(cosDelta, ksg.w);
    //     }
    // }



  
    float intersectClippedQuadric(mat4 A, vec4 e, vec4 d, mat4 B){
        float a = dot(d * A, d);
        float b = dot(d * A, e) + dot(e * A, d);
        float c = dot(e * A, e);
        float D = sqrt(b*b-4.0*a*c);
        float t1 = (-b + D) / (2.0*a);
        float t2 = (-b - D) / (2.0*a);
        vec4 h1 = e + (t1*d);
        vec4 h2 = e + (t2*d);
        if (dot(h1*B, h1) > 0.0){
            t1 = -1.0;
        }
        if (dot(h2*B, h2) > 0.0){
            t2 = -1.0;
        }
        return (t1<0.0)?t2:((t2<0.0)?t1:min(t1, t2));
    }

    float findBestHit(vec4 e, vec4 d, out int bestQuadricIndex)
    {
        float bestT = -1.0;
        for(int i = 0; i < 16; i++){
            float t = intersectClippedQuadric(quadrics[i], e, d, clippers[i]);
            if(t > 0.0 && (bestT < 0.0 || t < bestT)){
                bestT = t;
                bestQuadricIndex = i;
            }
        }
        return bestT;
    }

    vec3 DReflect(vec3 inDir, vec3 normal) {
        return inDir - normal * dot(normal, inDir) * 2.0;
    }

    vec3 DRefract(vec3 inDir, vec3 normal, float refractiveIndex) {
        float ri = refractiveIndex;
        float cosa = - dot(normal, inDir);
        if (cosa < 0.0) { cosa = -cosa; normal = -normal; ri = 1.0/ri; }      
        float disc = 1.0 - (1.0 - cosa * cosa) / ri / ri;       
        if (disc < 0.0) return reflect(inDir, normal);
        return inDir * (1.0/ri) + normal * (cosa / ri - sqrt(disc)) ;
    }

    vec3 IReflect(vec3 inDir, vec3 normal, vec3 minReflectance) {
        float cosa = abs(dot(normal, inDir));
        return minReflectance + (1.0-minReflectance)*pow( 1.0-cosa, 5.0 ); 
    }

    vec3 IRefract(vec3 inDir, vec3 normal, vec3 minReflectance) {
        return vec3(1.0, 1.0, 1.0) - IReflect(inDir, normal, minReflectance); 
    }

    float diffuseShading(vec4 p, vec4 N){
        vec4 lightDir = vec4(lightPoint, 0.0) - p;
        float lightDist = dot(lightDir, lightDir);
        vec4 lightDirNorm = vec4(normalize(lightDir.xyz), 0.0);
        int lightQuadraticIndex;
        float lightT = findBestHit(p + epsilon*N, lightDirNorm, lightQuadraticIndex);
        float intensity = 0.0;
        if (lightT < 0.0 || lightDist < (lightT * lightT)) {
            intensity = dot(N, lightDirNorm) * lightPower / (4.0*3.14*lightDist);
        }
        return intensity;
    }

    struct RRPoint
    {
        int i;
        vec4 p;
        vec4 d;
    };

    struct RRPointStack
    {
        int i;
        RRPoint data[16];
    };

    struct ColorStack
    {
        int i;
        vec4 data[16];
    };

    void RRPointStackPop(RRPointStack s){
        s.i--;
    }

    void RRPointStackPush(RRPointStack rs, ColorStack cs, RRPoint e){
        rs.data[rs.i++] = e;
        cs.data[cs.i++] = vec4(-1);
    }

    ColorStack ColorStackCreate(out ColorStack colorStack){
        for (int i = 0; i < 16; ++i)
        {
            colorStack.data[i] = vec4(-1);
        }
        return colorStack;
    }

    void ColorStackPop(ColorStack s){
        s.i--;
    }

    bool goLeft(RRPoint root, out RRPoint rrpoint, out vec4 color){
        vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);

        vec3 minReflectance = reflectance[root.i];
        // if (dot(minReflectance, minReflectance) == 0.0) {
        //     color = vec4(objectColor * diffuseShading(root.p, N),1);
        //     return false;
        // }
        
        vec4 reflectD = vec4(DReflect(root.d.xyz, N.xyz), 0.0);
        vec4 e = root.p + epsilon*reflectD;
        int quadricIndex;
        float t = findBestHit(e, reflectD, quadricIndex);
        bool isColor = (t <= 0.0);
        if (isColor) {
            color = vec4(texture(background, reflectD.xyz).rgb, 1);
            return false;
        }

        rrpoint.i = quadricIndex;
        rrpoint.p = e + t*reflectD;
        rrpoint.d = reflectD;
        return true;
    }

    bool goRight(RRPoint root, out RRPoint rrpoint, out vec4 color){
        vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);

        float refractiveIndex= refractiveIndicies[root.i];
        // if (refractiveIndex < 0.0) {
        //     color = vec4(objectColor * diffuseShading(root.p, N),1);
        //     return false;
        // }

        vec4 refractD = vec4(DRefract(root.d.xyz, N.xyz, refractiveIndex), 0.0);
        vec4 e = root.p + epsilon*refractD;
        int quadricIndex;
        float t = findBestHit(e, refractD, quadricIndex);
        bool isColor = (t <= 0.0);
        if (isColor) {
            color = vec4(texture(background, refractD.xyz).rgb, 1);
            return false;
        }

        rrpoint.i = quadricIndex;
        rrpoint.p = e + t*refractD;
        rrpoint.d = refractD;
        return true;
    }

    vec4 relfectRefract(vec4 e, vec4 d){
        int quadricIndex;
        float t = findBestHit(e, d, quadricIndex);
        if (t < 0.0){
            return vec4(texture(background, d.xyz).rgb, 1);
        }
        RRPoint root;
        root.i = quadricIndex;
        root.p = e + t*d;
        root.d = d;

        vec3 intensity = vec3(1,1,1);
        for (int i = 0; i < 10; ++i)
        {
            vec4 N = surfaceNormalSide(root.p, quadrics[root.i], root.d);
            if (dot(reflectance[root.i], reflectance[root.i]) > 0.0) {
                RRPoint left;
                vec4 leftColor;
                bool useRRPoint = goLeft(root, left, leftColor);
                if (useRRPoint){
                    root = left;
                } else {
                    return leftColor;
                }
            } else if (refractiveIndicies[root.i] > 0.0) {
                RRPoint right;
                vec4 rightColor;
                bool useRRPoint = goRight(root, right, rightColor);
                if (useRRPoint){
                    root = right;
                } else {
                    return rightColor;
                }
            } else {
                return vec4(objectColor * diffuseShading(root.p, N),1);
            }
        }
        return vec4(intensity, 1);
    }

  void main() {
    vec4 lightPoint4 = vec4(lightPoint, 0.0);
    vec4 d = vec4(normalize(rayDir.xyz), 0.0);
    vec4 e = eyePosition;
    fragmentColor = relfectRefract(e, d);
  }
`;