Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `#version 300 es 
    precision highp float;
    precision highp sampler3D;

    uniform vec4 eyePosition;
    uniform sampler3D volume;

    in vec4 rayDir;

    out vec4 fragmentColor;

    vec3 objectColor = vec3(1,1,1); //vec3(0.5, 0.5, 0.5);
    vec3 lightDir = normalize(vec3(1, 2, 0));
    float density = 0.1;
    float density2 = 0.7;
    int nLoops = 128;

    float epsilon = 1e-6;

    float noise(vec3 r) {
        float value = 0.999;
        if(abs(r[0]) < value && abs(r[1]) < value && abs(r[2]) < value){
            return texture(volume, r).r;
        } else {
            return -1.0;
        }
    }

    float getTStart(vec4 e, vec4 d, int axis){
        float tl = (-1.0 - e[axis]) / d[axis];
        float tr = (1.0 - e[axis]) / d[axis];
        return min(tl, tr);        
    }

    float getTEnd(vec4 e, vec4 d, int axis){
        float tl = (-1.0 - e[axis]) / d[axis];
        float tr = (1.0 - e[axis]) / d[axis];
        return max(tl, tr);        
    }

    float getTStartTotal(vec4 e, vec4 d){
        float tx = getTStart(e, d, 0);
        float ty = getTStart(e, d, 1);
        float tz = getTStart(e, d, 2);
        return max(max(tx, ty), tz);        
    }

    float getTEndTotal(vec4 e, vec4 d){
        float tx = getTEnd(e, d, 0);
        float ty = getTEnd(e, d, 1);
        float tz = getTEnd(e, d, 2);
        return min(min(tx, ty), tz);        
    }

    vec4 moveToSurface(vec4 e, vec4 d, out vec3 p){
        float tstart = max(getTStartTotal(e, d), 0.0);
        float tend = getTEndTotal(e, d);
        if(tend < 0.0) return vec4(0,0,0,1);

        p = (e + (tstart*d)).xyz;
        vec3 step =  d.xyz * min((tend - tstart)/float(nLoops), 0.05);
        p += step;
        float h = 0.0;
        float h_res = 0.0;
        float h_akk = 0.0;
        vec4 c_akk = vec4(0,0,0,1);
        int level;
        int prev_level;
        bool tmp = false;
        for(int i=0; i<nLoops; i++){
            h = noise(p);
            // if(h > h_res){
            //     h_res = h;
            // }
            if (h > density2)
            {
                level = 2;
                return vec4(1, 0, 0, 1);
            } else if(h > density) {
                level = 1;
                tmp = true;
                // return vec4(0, 1, 0, 1);
                // c_akk = vec4(0, 1, 0, 1) * 0.5;
            } else 

            if (level != prev_level)
            {
                if(level == 1) {
                    h_akk += (1.0-h_akk) * 0.5;
                    c_akk += (1.0-h_akk) * 0.5 * vec4(0, 0, 1, 1);
                } else if (level == 2)
                {
                    h_akk += (1.0-h_akk) * 0.5;
                    c_akk += (1.0-h_akk) * 0.5 * vec4(1, 0, 0, 1);
                    return vec4(1, 0, 0, 1);
                    // return c_akk;// vec4(1, 0, 0, 1);
                }                
            }
            p += step;
            prev_level = level;
        }
        if (tmp)
        {
            return vec4(0, 1, 0, 1);
        }
        // if (h_res < density) {
        //     return -1.0;
        // } else if(h_res < density2) {
        //     return density;
        // } else {
        //     return density2;
        // }
        c_akk[3] = 1.0;
        return c_akk;
    }

    bool checkLightVisible(vec4 e, vec4 d){
        vec3 p = e.xyz;
        vec3 step = d.xyz * 0.05;
        p += step;
        float h;
        for(int i=0; i<nLoops; i++){
            h = noise(p);
            if(h > density) break;
            p += step;
        }
        return h <= density;        
    }

    vec3 PhongShading(vec4 phong, vec3 N, vec3 d, vec3 lightDir, float lightPowerDensity) {
        vec3 ks = phong.xyz;
        float shininess = phong[3];
        float cosTheta = dot(N, lightDir);
        if(cosTheta < 0.0) {return vec3(0,0,0);}

        vec3 halfway = normalize(d + lightDir);
        float cosDelta = dot(N, halfway);
        if(cosDelta < 0.0) {return vec3(0,0,0);}

        return lightPowerDensity * ks * pow(cosDelta, shininess);
    }

    void main() {
        vec4 d = vec4(normalize(rayDir.xyz), 0.0);
        vec4 e = eyePosition;
        // fragmentColor = vec4(1, 1, 1, 1);

        vec3 p;
        // float h = moveToSurface(e, d, p);
        // fragmentColor = vec4(objectColor * h, 1);
        fragmentColor = moveToSurface(e, d, p);
        // if(h > density) {
        //     vec3 gradient = vec3(
        //         noise(p + vec3(+0.05, 0.0, 0.0) ) -
        //         noise(p + vec3(-0.05, 0.0, 0.0) ) ,
        //         noise(p + vec3(0.0, +0.05, 0.0) ) -
        //         noise(p + vec3(0.0, -0.05, 0.0) ) , 
        //         noise(p + vec3(0.0, 0.0, +0.05) ) -
        //         noise(p + vec3(0.0, 0.0, -0.05) ) 
        //         );
        //     vec3 N = normalize(gradient);
        //     bool lightVisible = checkLightVisible(vec4(p - (epsilon*lightDir), 0), vec4(lightDir, 0));
        //     if (lightVisible){
        //         float intensity = dot(N, -1.0 * lightDir);
        //         fragmentColor = vec4(objectColor * intensity, 1);
        //         fragmentColor += vec4(PhongShading(vec4(1,1,1,10), N, d.xyz, -1.0*lightDir, 1.0), 1);
        //         // fragmentColor = vec4(0, 1, 0, 1);
        //     } else {
        //         // fragmentColor = vec4(1, 0, 0, 1);
        //         fragmentColor = vec4(0, 0, 0, 1);
        //     }
        //     // fragmentColor = vec4(objectColor * h, 1); // Uncomment to turn off shadows and shading
        // } else {
        //     fragmentColor = vec4(1, 1, 1, 1);
        // }

    }
`;